import * as util from '../util';
/**
 * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating
 * a large ArrayBuffer.
 *
 * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads
 * its weights as a list of (usually) 4MB ArrayBuffers and then slices the
 * weight tensors out of them. For small models, it's safe to concatenate all
 * the weight buffers into a single ArrayBuffer and then slice the weight
 * tensors out of it, but for large models, a different approach is needed.
 */
export class CompositeArrayBuffer {
    constructor(buffers) {
        this.shards = [];
        this.previousShardIndex = 0;
        // Normalize the `buffers` input to be `ArrayBuffer[]`.
        if (!(buffers instanceof Array)) {
            buffers = [buffers];
        }
        buffers = buffers.map((bufferOrTypedArray) => {
            if (util.isTypedArray(bufferOrTypedArray)) {
                return bufferOrTypedArray.buffer;
            }
            return bufferOrTypedArray;
        });
        // Skip setting up shards if there are no buffers.
        if (buffers.length === 0) {
            return;
        }
        this.bufferUniformSize = buffers[0].byteLength;
        let start = 0;
        for (let i = 0; i < buffers.length; i++) {
            const buffer = buffers[i];
            // Check that all buffers except the last one have the same length.
            if (i !== buffers.length - 1 &&
                buffer.byteLength !== this.bufferUniformSize) {
                // Unset the buffer uniform size, since the buffer sizes are not
                // uniform.
                this.bufferUniformSize = undefined;
            }
            // Create the shards, including their start and end points.
            const end = start + buffer.byteLength;
            this.shards.push({ buffer, start, end });
            start = end;
        }
        // Set the byteLenghth
        if (this.shards.length === 0) {
            this.byteLength = 0;
        }
        this.byteLength = this.shards[this.shards.length - 1].end;
    }
    slice(start = 0, end = this.byteLength) {
        // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.
        start = isNaN(Number(start)) ? 0 : start;
        end = isNaN(Number(end)) ? 0 : end;
        // Fix the bounds to within the array.
        start = Math.max(0, start);
        end = Math.min(this.byteLength, end);
        if (end <= start) {
            return new ArrayBuffer(0);
        }
        const startShardIndex = this.findShardForByte(start);
        if (startShardIndex === -1) {
            // This should not happen since the start and end indices are always
            // within 0 and the composite array's length.
            throw new Error(`Could not find start shard for byte ${start}`);
        }
        const size = end - start;
        const outputBuffer = new ArrayBuffer(size);
        const outputArray = new Uint8Array(outputBuffer);
        let sliced = 0;
        for (let i = startShardIndex; i < this.shards.length; i++) {
            const shard = this.shards[i];
            const globalStart = start + sliced;
            const localStart = globalStart - shard.start;
            const outputStart = sliced;
            const globalEnd = Math.min(end, shard.end);
            const localEnd = globalEnd - shard.start;
            const outputSlice = new Uint8Array(shard.buffer.slice(localStart, localEnd));
            outputArray.set(outputSlice, outputStart);
            sliced += outputSlice.length;
            if (end < shard.end) {
                break;
            }
        }
        return outputBuffer;
    }
    /**
     * Get the index of the shard that contains the byte at `byteIndex`.
     */
    findShardForByte(byteIndex) {
        if (this.shards.length === 0 || byteIndex < 0 ||
            byteIndex >= this.byteLength) {
            return -1;
        }
        // If the buffers have a uniform size, compute the shard directly.
        if (this.bufferUniformSize != null) {
            this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);
            return this.previousShardIndex;
        }
        // If the buffers don't have a uniform size, we need to search for the
        // shard. That means we need a function to check where the byteIndex lies
        // relative to a given shard.
        function check(shard) {
            if (byteIndex < shard.start) {
                return -1;
            }
            if (byteIndex >= shard.end) {
                return 1;
            }
            return 0;
        }
        // For efficiency, try the previous shard first.
        if (check(this.shards[this.previousShardIndex]) === 0) {
            return this.previousShardIndex;
        }
        // Otherwise, use a generic search function.
        // This should almost never end up being used in practice since the weight
        // entries should always be in order.
        const index = search(this.shards, check);
        if (index === -1) {
            return -1;
        }
        this.previousShardIndex = index;
        return this.previousShardIndex;
    }
}
/**
 * Search for an element of a sorted array.
 *
 * @param sortedArray The sorted array to search
 * @param compare A function to compare the current value against the searched
 *     value. Return 0 on a match, negative if the searched value is less than
 *     the value passed to the function, and positive if the searched value is
 *     greater than the value passed to the function.
 * @returns The index of the element, or -1 if it's not in the array.
 */
export function search(sortedArray, compare) {
    // Binary search
    let min = 0;
    let max = sortedArray.length;
    while (min <= max) {
        const middle = Math.floor((max - min) / 2) + min;
        const side = compare(sortedArray[middle]);
        if (side === 0) {
            return middle;
        }
        else if (side < 0) {
            max = middle;
        }
        else {
            min = middle + 1;
        }
    }
    return -1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9zaXRlX2FycmF5X2J1ZmZlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvaW8vY29tcG9zaXRlX2FycmF5X2J1ZmZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpQkEsT0FBTyxLQUFLLElBQUksTUFBTSxTQUFTLENBQUM7QUFRaEM7Ozs7Ozs7OztHQVNHO0FBRUgsTUFBTSxPQUFPLG9CQUFvQjtJQU0vQixZQUFZLE9BQ0U7UUFOTixXQUFNLEdBQWtCLEVBQUUsQ0FBQztRQUMzQix1QkFBa0IsR0FBRyxDQUFDLENBQUM7UUFNN0IsdURBQXVEO1FBQ3ZELElBQUksQ0FBQyxDQUFDLE9BQU8sWUFBWSxLQUFLLENBQUMsRUFBRTtZQUMvQixPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNyQjtRQUNELE9BQU8sR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsa0JBQWtCLEVBQUUsRUFBRTtZQUMzQyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsRUFBRTtnQkFDekMsT0FBTyxrQkFBa0IsQ0FBQyxNQUFNLENBQUM7YUFDbEM7WUFDRCxPQUFPLGtCQUFrQixDQUFDO1FBQzVCLENBQUMsQ0FBQyxDQUFDO1FBRUgsa0RBQWtEO1FBQ2xELElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDeEIsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7UUFDL0MsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBRWQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDdkMsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFCLG1FQUFtRTtZ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KiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuaW1wb3J0IHtUeXBlZEFycmF5fSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG50eXBlIEJ1ZmZlclNoYXJkID0ge1xuICBzdGFydDogbnVtYmVyLFxuICBlbmQ6IG51bWJlcixcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcbn07XG5cbi8qKlxuICogV3JhcHMgYSBsaXN0IG9mIEFycmF5QnVmZmVycyBpbnRvIGEgYHNsaWNlKClgLWFibGUgb2JqZWN0IHdpdGhvdXQgYWxsb2NhdGluZ1xuICogYSBsYXJnZSBBcnJheUJ1ZmZlci5cbiAqXG4gKiBBbGxvY2F0aW5nIGxhcmdlIEFycmF5QnVmZmVycyAofjJHQikgY2FuIGJlIHVuc3RhYmxlIG9uIENocm9tZS4gVEZKUyBsb2Fkc1xuICogaXRzIHdlaWdodHMgYXMgYSBsaXN0IG9mICh1c3VhbGx5KSA0TUIgQXJyYXlCdWZmZXJzIGFuZCB0aGVuIHNsaWNlcyB0aGVcbiAqIHdlaWdodCB0ZW5zb3JzIG91dCBvZiB0aGVtLiBGb3Igc21hbGwgbW9kZWxzLCBpdCdzIHNhZmUgdG8gY29uY2F0ZW5hdGUgYWxsXG4gKiB0aGUgd2VpZ2h0IGJ1ZmZlcnMgaW50byBhIHNpbmdsZSBBcnJheUJ1ZmZlciBhbmQgdGhlbiBzbGljZSB0aGUgd2VpZ2h0XG4gKiB0ZW5zb3JzIG91dCBvZiBpdCwgYnV0IGZvciBsYXJnZSBtb2RlbHMsIGEgZGlmZmVyZW50IGFwcHJvYWNoIGlzIG5lZWRlZC5cbiAqL1xuXG5leHBvcnQgY2xhc3MgQ29tcG9zaXRlQXJyYXlCdWZmZXIge1xuICBwcml2YXRlIHNoYXJkczogQnVmZmVyU2hhcmRbXSA9IFtdO1xuICBwcml2YXRlIHByZXZpb3VzU2hhcmRJbmRleCA9IDA7XG4gIHByaXZhdGUgYnVmZmVyVW5pZm9ybVNpemU/OiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBieXRlTGVuZ3RoOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoYnVmZmVyczogQXJyYXlCdWZmZXIgfCBBcnJheUJ1ZmZlcltdIHwgVHlwZWRBcnJheSB8XG4gICAgVHlwZWRBcnJheVtdKSB7XG4gICAgLy8gTm9ybWFsaXplIHRoZSBgYnVmZmVyc2AgaW5wdXQgdG8gYmUgYEFycmF5QnVmZmVyW11gLlxuICAgIGlmICghKGJ1ZmZlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIGJ1ZmZlcnMgPSBbYnVmZmVyc107XG4gICAgfVxuICAgIGJ1ZmZlcnMgPSBidWZmZXJzLm1hcCgoYnVmZmVyT3JUeXBlZEFycmF5KSA9PiB7XG4gICAgICBpZiAodXRpbC5pc1R5cGVkQXJyYXkoYnVmZmVyT3JUeXBlZEFycmF5KSkge1xuICAgICAgICByZXR1cm4gYnVmZmVyT3JUeXBlZEFycmF5LmJ1ZmZlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJPclR5cGVkQXJyYXk7XG4gICAgfSk7XG5cbiAgICAvLyBTa2lwIHNldHRpbmcgdXAgc2hhcmRzIGlmIHRoZXJlIGFyZSBubyBidWZmZXJzLlxuICAgIGlmIChidWZmZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyVW5pZm9ybVNpemUgPSBidWZmZXJzWzBdLmJ5dGVMZW5ndGg7XG4gICAgbGV0IHN0YXJ0ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgIC8vIENoZWNrIHRoYXQgYWxsIGJ1ZmZlcnMgZXhjZXB0IHRoZSBsYXN0IG9uZSBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgICAgIGlmIChpICE9PSBidWZmZXJzLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgYnVmZmVyLmJ5dGVMZW5ndGggIT09IHRoaXMuYnVmZmVyVW5pZm9ybVNpemUpIHtcbiAgICAgICAgLy8gVW5zZXQgdGhlIGJ1ZmZlciB1bmlmb3JtIHNpemUsIHNpbmNlIHRoZSBidWZmZXIgc2l6ZXMgYXJlIG5vdFxuICAgICAgICAvLyB1bmlmb3JtLlxuICAgICAgICB0aGlzLmJ1ZmZlclVuaWZvcm1TaXplID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHNoYXJkcywgaW5jbHVkaW5nIHRoZWlyIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLlxuICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgIHRoaXMuc2hhcmRzLnB1c2goeyBidWZmZXIsIHN0YXJ0LCBlbmQgfSk7XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGJ5dGVMZW5naHRoXG4gICAgaWYgKHRoaXMuc2hhcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5zaGFyZHNbdGhpcy5zaGFyZHMubGVuZ3RoIC0gMV0uZW5kO1xuICB9XG5cbiAgc2xpY2Uoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmJ5dGVMZW5ndGgpOiBBcnJheUJ1ZmZlciB7XG4gICAgLy8gTmFOIGlzIHRyZWF0ZWQgYXMgemVybyBmb3Igc2xpY2luZy4gVGhpcyBtYXRjaGVzIEFycmF5QnVmZmVyJ3MgYmVoYXZpb3IuXG4gICAgc3RhcnQgPSBpc05hTihOdW1iZXIoc3RhcnQpKSA/IDAgOiBzdGFydDtcbiAgICBlbmQgPSBpc05hTihOdW1iZXIoZW5kKSkgPyAwIDogZW5kO1xuXG4gICAgLy8gRml4IHRoZSBib3VuZHMgdG8gd2l0aGluIHRoZSBhcnJheS5cbiAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0KTtcbiAgICBlbmQgPSBNYXRoLm1pbih0aGlzLmJ5dGVMZW5ndGgsIGVuZCk7XG4gICAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFNoYXJkSW5kZXggPSB0aGlzLmZpbmRTaGFyZEZvckJ5dGUoc3RhcnQpO1xuICAgIGlmIChzdGFydFNoYXJkSW5kZXggPT09IC0xKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuIHNpbmNlIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMgYXJlIGFsd2F5c1xuICAgICAgLy8gd2l0aGluIDAgYW5kIHRoZSBjb21wb3NpdGUgYXJyYXkncyBsZW5ndGguXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHN0YXJ0IHNoYXJkIGZvciBieXRlICR7c3RhcnR9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xuICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICBjb25zdCBvdXRwdXRBcnJheSA9IG5ldyBVaW50OEFycmF5KG91dHB1dEJ1ZmZlcik7XG4gICAgbGV0IHNsaWNlZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0U2hhcmRJbmRleDsgaSA8IHRoaXMuc2hhcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaGFyZCA9IHRoaXMuc2hhcmRzW2ldO1xuXG4gICAgICBjb25zdCBnbG9iYWxTdGFydCA9IHN0YXJ0ICsgc2xpY2VkO1xuICAgICAgY29uc3QgbG9jYWxTdGFydCA9IGdsb2JhbFN0YXJ0IC0gc2hhcmQuc3RhcnQ7XG4gICAgICBjb25zdCBvdXRwdXRTdGFydCA9IHNsaWNlZDtcblxuICAgICAgY29uc3QgZ2xvYmFsRW5kID0gTWF0aC5taW4oZW5kLCBzaGFyZC5lbmQpO1xuICAgICAgY29uc3QgbG9jYWxFbmQgPSBnbG9iYWxFbmQgLSBzaGFyZC5zdGFydDtcblxuICAgICAgY29uc3Qgb3V0cHV0U2xpY2UgPSBuZXcgVWludDhBcnJheShzaGFyZC5idWZmZXIuc2xpY2UobG9jYWxTdGFydCxcbiAgICAgICAgbG9jYWxFbmQpKTtcbiAgICAgIG91dHB1dEFycmF5LnNldChvdXRwdXRTbGljZSwgb3V0cHV0U3RhcnQpO1xuICAgICAgc2xpY2VkICs9IG91dHB1dFNsaWNlLmxlbmd0aDtcblxuICAgICAgaWYgKGVuZCA8IHNoYXJkLmVuZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBzaGFyZCB0aGF0IGNvbnRhaW5zIHRoZSBieXRlIGF0IGBieXRlSW5kZXhgLlxuICAgKi9cbiAgcHJpdmF0ZSBmaW5kU2hhcmRGb3JCeXRlKGJ5dGVJbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5zaGFyZHMubGVuZ3RoID09PSAwIHx8IGJ5dGVJbmRleCA8IDAgfHxcbiAgICAgIGJ5dGVJbmRleCA+PSB0aGlzLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYnVmZmVycyBoYXZlIGEgdW5pZm9ybSBzaXplLCBjb21wdXRlIHRoZSBzaGFyZCBkaXJlY3RseS5cbiAgICBpZiAodGhpcy5idWZmZXJVbmlmb3JtU2l6ZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnByZXZpb3VzU2hhcmRJbmRleCA9IE1hdGguZmxvb3IoYnl0ZUluZGV4IC8gdGhpcy5idWZmZXJVbmlmb3JtU2l6ZSk7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91c1NoYXJkSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGJ1ZmZlcnMgZG9uJ3QgaGF2ZSBhIHVuaWZvcm0gc2l6ZSwgd2UgbmVlZCB0byBzZWFyY2ggZm9yIHRoZVxuICAgIC8vIHNoYXJkLiBUaGF0IG1lYW5zIHdlIG5lZWQgYSBmdW5jdGlvbiB0byBjaGVjayB3aGVyZSB0aGUgYnl0ZUluZGV4IGxpZXNcbiAgICAvLyByZWxhdGl2ZSB0byBhIGdpdmVuIHNoYXJkLlxuICAgIGZ1bmN0aW9uIGNoZWNrKHNoYXJkOiBCdWZmZXJTaGFyZCkge1xuICAgICAgaWYgKGJ5dGVJbmRleCA8IHNoYXJkLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlSW5kZXggPj0gc2hhcmQuZW5kKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gRm9yIGVmZmljaWVuY3ksIHRyeSB0aGUgcHJldmlvdXMgc2hhcmQgZmlyc3QuXG4gICAgaWYgKGNoZWNrKHRoaXMuc2hhcmRzW3RoaXMucHJldmlvdXNTaGFyZEluZGV4XSkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzU2hhcmRJbmRleDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBhIGdlbmVyaWMgc2VhcmNoIGZ1bmN0aW9uLlxuICAgIC8vIFRoaXMgc2hvdWxkIGFsbW9zdCBuZXZlciBlbmQgdXAgYmVpbmcgdXNlZCBpbiBwcmFjdGljZSBzaW5jZSB0aGUgd2VpZ2h0XG4gICAgLy8gZW50cmllcyBzaG91bGQgYWx3YXlzIGJlIGluIG9yZGVyLlxuICAgIGNvbnN0IGluZGV4ID0gc2VhcmNoKHRoaXMuc2hhcmRzLCBjaGVjayk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHRoaXMucHJldmlvdXNTaGFyZEluZGV4ID0gaW5kZXg7XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNTaGFyZEluZGV4O1xuICB9XG59XG5cbi8qKlxuICogU2VhcmNoIGZvciBhbiBlbGVtZW50IG9mIGEgc29ydGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSBzb3J0ZWRBcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIHNlYXJjaFxuICogQHBhcmFtIGNvbXBhcmUgQSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBjdXJyZW50IHZhbHVlIGFnYWluc3QgdGhlIHNlYXJjaGVkXG4gKiAgICAgdmFsdWUuIFJldHVybiAwIG9uIGEgbWF0Y2gsIG5lZ2F0aXZlIGlmIHRoZSBzZWFyY2hlZCB2YWx1ZSBpcyBsZXNzIHRoYW5cbiAqICAgICB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiwgYW5kIHBvc2l0aXZlIGlmIHRoZSBzZWFyY2hlZCB2YWx1ZSBpc1xuICogICAgIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCwgb3IgLTEgaWYgaXQncyBub3QgaW4gdGhlIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoPFQ+KHNvcnRlZEFycmF5OiBUW10sIGNvbXBhcmU6ICh0OiBUKSA9PiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBCaW5hcnkgc2VhcmNoXG4gIGxldCBtaW4gPSAwO1xuICBsZXQgbWF4ID0gc29ydGVkQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChtaW4gPD0gbWF4KSB7XG4gICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIDIpICsgbWluO1xuICAgIGNvbnN0IHNpZGUgPSBjb21wYXJlKHNvcnRlZEFycmF5W21pZGRsZV0pO1xuXG4gICAgaWYgKHNpZGUgPT09IDApIHtcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfSBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgbWF4ID0gbWlkZGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW4gPSBtaWRkbGUgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG4iXX0=