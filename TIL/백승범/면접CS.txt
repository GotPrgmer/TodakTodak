책임주도설계:
캡슐화
객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용
클래스가 아닌 객체에 초점을 맞춰야 함
객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 생각
추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계를 만들 수 있음
설계가 구체적인 상황에 결합되는 방지하기 위해 추상화가 필요한 것임
객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후 역할을 수행할 수 있는
적절한 객체에게 적절한 책임을 할당하는 것임
객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력임
객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것임
객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력임. 객체의 상태를 결정하는 것은 객체의 행동임.
객체의 책임은 객체가 무엇을 알고 있는가와 무엇을 할 수 있는가로 구성됨
객체의 구현 방법은 상대적으로 책임보다 덜 중요하며, 책임을 결정한 다음에 고민해도 늦지 않음.
객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고, 이를 객체들에게 할당하는 반복적인
과정을 통해 모양을 갖춰나감. 즉, 최초의 책임을 애플리케이션이 제공하는 기능으로 두는 것임.
객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어짐. 이런 메시지가 메시지를
수신할 객체의 책임을 결정함.
결정된 메시지가 객체의 퍼블릭 인터페이스를 구성함.
책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임주도 설계라고 부름.
책임을 할당할 때 고려해야 하는 두 가지 요소로, 하나는 메시지가 객체를 결정해야 한다는 것이고, 다른 하나는 행동이 상태를 결정한다는 것임.
객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아닌 상태에 초점을 맞추는 것임.
객체지향 커뮤니티에서 오랜 기간 동안 좋은 설계의 특징을 판단할 수 있는 기준을 캡슐화, 응집도, 결합도라고 정함.
객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것임.
응집도는 모듈에 포함된 내부요소들이 연관돼 있는 정도를 나타내고 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게
협력한다면 높은 응집도를 가짐. 또한, 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 함께 변경되어야 한다면
응집도가 낮은 것임.
단일책임 원칙은 클래스는 단 한 가지의 변경 이유만을 가져야 한다는 설계 원칙임.
결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도임. 변경의 관점에서 결합도는 한 모듈이
변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있음.
다른 객체에게 접근자 메서드를 통해 값을 변경할 기회를 주지 말고, 본인이 직접 바꿀 수 있도록 해야 캡슐화가 이루어짐.
내부 구현 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것임.
메시지를 결정한 후에 객체를 선택해야 함. 메시지가 객체를 선택하게 해야 하는 것임.
메시지 기반 설계 관점은 클래스 기반의 설계 관점보다 훨씬 유연한 애플리케이션을 만들수 있게 해줌.
메시지를 먼저 결정하기 때문에 메시지 송신자는 메시지 수신자에 대한 어떠한 가정도 할 수 없음. 메시지 전송자의 관점에서 메시지 수신자가
깔끔하게 캡슐화되는 것임.
GRASP 패턴은 책임 할당의 어려움을 해결하기 위한 답을 제시해줌. 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴
형식으로 정리한 것임.
클라이언트가 합성에서 요구되는 객체 생성 책임(new)을 져서 결합도가 올라가는 게 싫으면 Factory 패턴을 사용하면 됨. 클라이언트는
Factory 객체의 내부 구현이 아닌 단지 인스턴스만 반환해준다는 것만 알면 됨.
설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것 으로부터 시작하는 것이 좋음.
코드를 수정하지 않고도 변경을 수용하는 방법이 바로 합성임.
절차형 코드로 실행되는 프로그램을 빠르게 작성한 후 완성된 코드를 객체지향적 코드로 변경하는 리팩터링 기법을 사용하는 것이 베스트임.

